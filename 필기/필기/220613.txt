● 상속(p. 239)
: 상하 계층 구조를 가지고 있는 클래스간에, 아래 클래스가 위의 클래스의 특징을 그대로 물려받는 것
  기존에 존재하는 유사한 클래스로부터 속성과 동작을 이어받고 자신이 필요한 기능을 추가하는 기법
각 클래스 별로 공통점이 있을 때, 
공통적인 계층구조를 만들어서 하나의 특성을 미리 정의해두고, 특성을 모두 가지는 아래의 클래스에 모두 적용하는 기법
-ex 사람은 이름과 나이가 존재 -> 사람에 정의
	개발자, 학생, 작가별 차이가 있지만 사람의 특성을 지정해두고 아래의 클래스에 위 특성을 적용
- 공통적인 메소드를 똑같이 여러 번 사용 -> 비효율적
- 상속을 통해 시간 절약, 버그 줄여주기(super 생성자 상속이 잘되는지 확인 후 사용해야 부모 class 문제 있을 때 빠르게 수정 가능)
▶ 클래스 구조 간 부모(상위) / 자식(하위) 클래스라고 칭함 -> 자식 클래스는 부모 클래스를 물려받음
	부모 클래스 = 수퍼 클래스(superclass) = 베이스 클래스(base class)
	자식 클래스 = 서브 클래스(subclass) = 파생된 클래스(derived class)
▶ is-a 관계 = '~은 ~이다'
: 상속관계에서는 is a 관계가 말이(성립) 되어야지 사용할 수 있음
- 계층구조가 올바르게 성립이 되었는지 확인
- ex. 사자는 동물이다, 개는 동물이다
- has-a(포함, ~은 ~을 가지고 있다) 는 필드로 만들어야 함, 상속x
	ex. 도서관은 책을 가지고 있다.
▶ 자식클래스가 다른 자식을 가져서 부모클래스가 되기도 함
▶ 부모 클래스에 필드, 메소드가 있으면 자식 클래스가 모두 상속받아서 사용 가능
▶ 사용
: public class 하위클래스명 extends 상위클래스명 {}
-> 상속을 원래 있던 것에서 확장(extend)한다는 의미로 해석 하면 됨
- 상위 클래스에 있는 필드와 메소드를 중복해서 사용할 필요 없음
- 하위 클래스에만 필요한 필드와 메소드는 하위 클래스에 따로
▶ 부모의 생성자 호출 super(생성자명, 생성자명);
- super는 수퍼클래스의 메소드나 필드를 명시적으로 참조하기 위해 사용
- 수퍼클래스의 호출은 생성자의 첫문장이어야 호출 가능
- 부모 클래스의 필드가 private로 선언되어있으면 자식 class가 가져올 수 없음
	-> 필드를 초기화하는 부모의 생성자가 public하면 자식에서 호출이 가능하므로 부모의 생성자를 호출
- 부모에 새 인스턴스 만들어서 값 초기화하하면 부모 인스턴스 1개가 생긴 것, 자식 인스턴스에서 참조하려면 원래 참조하던 대로만 가능
	ex. Person p = new Person("사람이름", 22); // 이름과 나이를 가지는 사람 class 생성
		// -> Student s2 = new Student(p.getName(), p.getAge(), 22);
		// (필드가 public으로 선언) -> Student(p.name, p.age); 로 부르기

- super class 변경시 subclass에 영향을 줌(반대는 x)
- 상속의 횟수는 제한x - 상속에 상속, 또 상속에 상속 가능
- 다중 상속 허용x -> java에선 부모 2개 이상 두고 자식클래스를 만들 수 없음, 하나의 부모만 가능
	'다이아몬드 상속'과 같이 상속이 어디가 어디에서 받았는지 혼란생기므로
	=> interface로 간접적으로 설정 가능
- 키워드를 통해 상속 제한은 가능
- 자식 클래스의 기본생성자는 부모클래스에서 받아온 생성자를 호출함, 부모 클래스의 기본생성자의 값을 그대로 받아서 옴
▶ super.메소드이름 으로 자식클래스에서 부모메소드 호출 가능, 필드도!

- 상속을 사용해서 오히려 부모 클래스를 수정했을 때 자식 클래스들이 모두 영향을 받으므로 오히려 불편해질 수 있으므로 잘 사용해야함
- 서브 클래스에서 수퍼 클래스와 동일한 이름의 필드를 정의하면 서브클래스의 필드가 무조건 수퍼클래스의 타입이 달라도 수퍼클래스의 필드를 가리키므로 서브 클래스에서 수퍼클래스 필드 참조시 super 무조건 써야하므로 피하는 것이 좋음


* 접근제한자 (아래로 갈 수록 접근 범위 증가)
private : 자기 자신만 볼 수 있음
default : 같은 패키지에선 동일하게 볼 수 있음
- ex. package class Person {
	int age;} // default package 필드 선언
protected : 자식들이 접근할 수 있도록 만들어둔 접근제한자, 같은 패키지에서도 볼 수 있음(+다른 패키지의 자식도 접근 가능)
public : 어디서든 볼 수 있음

* 생성자 초기화
-Generate Constructors from SuperClass 눌러도 super 초기화 나옴
클래스는 필드를 초기화하는 생성자가 무조건 1개는 있음(안보여도 기본생성자 있음)
초기화를 담당하는 생성자를 명시적으로 작성해도 됨, 생략도 가능
자식 class에서 기본생성자는 자식이 가진 자신의 필드는 자신이 초기화, 부모가 가진 필드는 부모로부터 초기화해서 super로 가져옴
명시적으로 적지 않으면 모두 기본생성자로 초기화됨, 
이 때 부모의 클래스에 생성자를 하나 명시적으로 파라미터를 전달받는 경우를 만들면 자식에서는 부모의 기본생성자를 호출할 수 없어짐 -> 기본생성자가 사라졌으므로 원래대로 호출하면 자식클래스에서 error가 남
	=> 1. 자식에서 원래대로 호출하도록 부모클래스에서 기본생성자 만들어주기
	=> 2. 자식에서 부모클래스 파라미터에 맞게 값을 넣어서 임의의 값으로 초기화시켜주기(기본생성자 필요하면 다시 만들어주면 됨, + 부모것도)
	=> 3. 자식 클래스에도 부모에 맞게 파라미터 넣어서 부모클래스 초기화, 자식클래스 자기 것도 초기화시키기
	ex. public Manager(String name, String address, int salary, int RRN, int bonus) {
		super(name, address, salary, RRN);
		this.bonus = bonus;
	}

● override(메소드 재정의) (p.248)
부모 클래스를 추상적으로 정해두므로 자식에서는 자세하고 명확하게(구체적으로) 동작하도록 하는 것 -> 확장
▶ 코드로 작성
: 부모 클래스에 있는 메소드를 헤더부분을 그대로 복사해서 자식 클래스에 그대로 붙여넣고, 바디부분을 추가 작성해 구체적으로 작성
-> 부모 클래스에서 받아온 하나의 메소드(동작)를 자식 클래스에서 새롭게 써내려간 것
▶ compile 시 override 제대로 했는지 확인 -> @Override
: 부모 메소드와 헤더부분 다르게 작성한 자식 메소드 위에 @Override쓰고 compile 해주면 compile error가 메소드 헤드부분을 잘못썼다고 알려주고, 수정하면 error 사라짐
* @~ : annotation(주석)이라고 부름
- 슈퍼 클래스의 헤더와 서브 클래스의 헤더가 동일해야 함 -> 메소드 이름, 반환형, 매개변수 개수, 데이터 타입 일치해야함
- 접근 지정자(제한자)의 경우 슈퍼 클래스의 메소드보다 같거나 넓은 범위로만 지정 가능
* 오버로딩은 메소드가 다양한 타입에 대응하기 위해 만드는 것(상속구조x), 오버라이드는 언제나 상속구조가 있어야함


● 클래스 다이어그램
: 그림을 통해 클래스간 관계를 나타낸 것
사각형 안에 클래스 적고, 관계는 상하관계로 두고 화살표로 그어둔 것, 화살표 머리가 가있는곳이 부모 class
▶ eclipse 플러그인 설치 
amateras-modeler 검색 - https://github.com/takezoe/amateras-modeler Installation 사이트 클릭 - http://takezoe.github.io/amateras-update-site 복사 - eclips help에 install new software에 붙여넣기 enter - 아래 체크사항 체크 후 next - accept하고 finish하면 설치되고 중간에 경고창 뜨면 install - restart 하라고 하면 restart하면 됨
▶ class diagram 실행
폴더 package에서 new - other - AmaterasUML - class diagram
▶ class diagram 만들어서 파일 만들기
① 클래스 만들기
왼쪽 ⓒ Class 클릭해서 빈화면에 드래그하고 클래스 이름 설정
② 필드 설정
클래스 이름 우클릭 - add attribute
- 클래스 우측attribute 왼쪽 빨간색 or - = private / + = public
- 필드명: 필드타입
③ 메소드 설정
클래스 이름 우클릭 - add operation
-메소드이름(파라미터): 타입
=> 저장 후 Java - export 해서 저장 폴더 설정 후 저장하면 파일 생김
▶ 파일 드래그해서 cld파일에 놓으면 만들어 놓은 파일의 관계가 class diagram으로 바로 출력
- auto layout 누르면 알아서 layout 잡아줌