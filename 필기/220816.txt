● 마우스 우클릭 - 검사 - >>에서 application 선택 - cookies에 cookie 확인 가능

● cookie는 브라우저, 즉 사용자가 가지고 있으므로 application에서 마음대로 생성, 수정, 삭제가 가능함 -> 사용자가 조작할 수 없게 개발자가 해두어야함
===> 해결 방법 : server가 기억하도록 하기

● 세션 : client가 기억할 정보를 server에서 기억하는 것
- client들은 웹서버에 요청이 끝나면 접근을 막아버림 -> server에 들어오는 여러 요청이 같은 client에게서 일어나고 있는지 판별 필요
	-> cookie로! : 특정한 cookie값이 있는지 없는지 여부로 판별해서 처음 온 client인지 확인 + 새로운 특정 cookie 부여(client 100번이야!), 그 뒤에는 특정한 cookie로 본인의 정체성을 요청에 담아서 보내므로 판별 가능
	- 조작을 통해 탈취 가능, 다른 client인 척 가능
- 세션은 한 번 만들어지면 꽤 오랜시간 유지됨, 같은 아이디로 한 번 더 접근하면 유지해줌 but 특정 시간이 지날동안 같은 id로 접근하지 않으면 그 때 지움 -> 시간 단위로 정보가 유지됨(서버별로 시간 차이, tomcat은 30분)
- 응용 소프트웨어를 껐다 켜면 초기화, 브라우저 시크릿모드로 접근해도 다른 브라우저로 인식해 값 차이(cookie 없으므로) but 같은 브라우저 안에서는 같은 값을 가지고 있음(ex. 탭 여러개 켜기)
▶ session.invalidate(); : 세션 종료
- 세션 종료 후 다시 세션 들어가면 id값 변경되어있음
- 값을 계속 사용할 때에는 request보다 session이 적합, 필요하면 cookie에 값을 저장해서 사용할 수도 있음
* application은 범위가 너무 넓어서 한 유저를 특정하기 어렵고, 언제 바뀌는지 추적핼야하므로 구동할 때 필요한 설정값들을 담을 때 사용

● filter : 서버와 servlet 사이에서 servlet에게 전달하기 전에 걸러주는 것
- 사용자 요청에 따라서 mapping되어 실행 (사용자 걸러서 요청 받아서 할 수 있음)
▶ dofilter 전 -> 서블릿이 요청 객체를 다루기 전, dofilter  -> 서블릿에게 원래 요청을 전달, dofilter 후 -> servlet이 요청을 처리하고 응답 보내기 전
- web.xml에 <filter>,<filter-mapping>해줘야함 -> 원래는 servlet으로 요청이 바로 전달되어야하는데, filter에 요청값 전달되고, servlet실행되고 filter 거쳐서 응답으로 날아옴
	-> filter-mapping 여러 개 해주면 한 필터 여러 군데 사용 가능, url-pattern만 맞춰주면 여러곳에서 재활용 가능해짐
- @WebFilter() : 괄호안에 filterName, urlPatterns 등 지정 가능
	-  /* : 사용자가 보내는 모든 요청에 대한 패턴 매칭 (서블릿에선 /* 사용x)
- 같은 주소에도 여러 개의 필터가 동작할 수 있음 -> annotation(@WebFilter)에서 설정하면 순서 정할 수 x, web.xml에선 먼저 적힌 친구가 먼저 적용됨

● InitParameter : 미리 설정하고 싶은 값을 설정해두는 것, config객체에 이름과 값으로 다 포함이 됨(객체에 담김)
	- web.xml에 있으면 서버 구동할 때, filter안에서는 filter 클래스가 로드될 때 생성됨

● Listener : 특정한 타이밍에 실행 (filter와 다름)
- 누가 요청했는지 알기 어려움
▶ ServletContextListener : 웹 어플리케이션 구동시에 실행
	- contextInitialized : 웹 어플리케이션 구동시 servletcontext 이벤트가 발생을 하고, contextIntialized가 호출됨
	- db 설정등에 쓰기 좋음
	- web.xml에서 <listener>에 클래스위치만 써주면 됨
-----------  request listener-----------
▶ ServletRequestListener : 사용자 요청이 발생했을 때
- @WebListener : 특정한 값을 넣을 게 없음 (annotaition)
▶ ServletRequestAttributeListener : 요청 객체에 attribute가 설정되었을 때
------------session listener---------
▶ HttpSessionListener : 세션이 실행됐을 때
▶ HttpSessionIdListener : 아이디가 변경되었을때
▶ HttpSessionBindingListener: 세션에 attribute값을 심고, 수정할 때

● Connection pool : 객체를 여러 개 만들어두고 계속해서 필요할 때 쓰고 반납하는 방식
	- ex. db connection 매번 만들고 다 쓰면 닫기 -> 필요할 때 꺼내 쓰기
- 구현을 하진 않고, 데이터 커넥션 풀 -> appache common dbcp2
- apache common dbcp2 검색 - org.apache.commons » commons-dbcp2 - Maven Repository 클릭 - 2.9.0 jar 다운
- jar파일 받은 곳에서 Compile Dependencies - logging, object pool(왼오 관계x) 새탭열기 - 두 개 다 jar 다운

