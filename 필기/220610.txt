<공부 내용>
배열 정렬(+삽입) / 원시형 자료 객체화 / 2차원 배열 / Method Overloading
--------------------------------------------------------------------------------------------------
● Arrays.sort(); 
: 배열 정렬 메소드
- 파라미터 : 배열 1개 참조 -> 해당 배열 정렬
▶ 정렬 기준이 없으면 error나고 정렬을 할 수 없음

● 삽입 정렬
: 데이터의 자리를 밀어내고 삽입됨, 오름차순으로 정렬됨
https://ko.wikipedia.org/wiki/%EC%A0%95%EB%A0%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98 정렬알고리즘 참고

▷ 정렬에 의미를 줘서 값을 찾기
이진검색 - Arrays.binarySearch(정렬,찾고자하는 값); -> 원소값에 겹치는 값이 없어야 올바른 위치를 찾을 수 있음
- 중복 시에는 겹치는 값 개수 체크하고 인덱스 번호 찾아야함

● java의 원시형 자료들은 객체가 아님 -> 원시형 자료를 객체로 포장해주는 class
1) wrapper
▶ 기본형  타입에 대응되는 Wrapper Class;
		Byte;
		Short;
		Integer;
		Long
		Float
		Double
		Character
		Boolean
▶ boxing : 박스에 담아서 포장 = 원시형 자료를 객체로 포장 -> 행동을 가지는 메소드를 사용하고 싶을 때 boxing
Integer i = new Integer(10); // i라는 객체로 Integer(10) 참조, 1.8버전 이후 Integer는 deprecated(사라짐), 다른걸로 변경
		Integer 12 = Integer.ValueOf(500); // 

* List라는 객체는 원시형 타입을 다룰 수 없음

● 2차원 배열 : 배열을 원소로 가지는 배열
- 생성 : ex. int[][] arr2d = new int[3][5]; // int[배열의 길이][하나의 배열원소의 길이값] = int[행의 개수][열의 개수] like 표
- 호출 : ex. System.out.println(arr2d[0][0]); // int[배열원소index][배열원소의 원소 index]
- 선언, 초기화 동시에 가능 :  ex. int[][] arrAnother = { {2, 4, 6}, {3, 6, 9}, {4, 8, 12} };
- int 배열의 원소로 참조를 하므로 배열만 참조할 수 있으면 열의 개수 안 써도 됨 

● Method Overloading
: 다양한 타입에 대응하기 위한 메소드
-메소드 이름이 같아도 파라미터의 타입, 순서, 개수가 다르면 다른 메소드로 인식(파라미터 이름은 관계x, return 타입도 관계x)
-생성자 초기화하는 것과 비슷 -> 생성자 overloading이라고 부름