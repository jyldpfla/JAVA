프로그램에서 error -> 프로그램을 이어갈 수 없어서 프로그램이 바로 종료됨
예외 처리 -> try-catch문
-예외가 발생되지 않았다면, 위에서 아래로 정상흐름, catch문 쓰이지 않고 순차적으로 쭉 내려감
-예외가 발생됐다면, 예외가 발생한 파트에서 catch문으로 바로 넘어가고 그 안에서 예외처리가 일어남
-try-catch문도 블록을 가지므로 지역변수의 범위 확인하며 사용해야함

array index를 넘어가는 error -> ArrayIndexOutOfBoundsException
범용적으로 일어나는 error -> Exception(예외)라는 부모클래스
=> 프로그램은 순차적으로 읽으므로 부모타입의 클래스가 자식타입의 예외처리보다 위에있으면 자식타입의 예외처리 사용x, 부모클래스가 가장 아래에 위치하는 것이 올바름
* 예외객체를 상속받는 RunTimeException

try-catch와 함께 오는 finally문
: 예외 여부와 관계없이 무조건적 실행 -> try문에서 예외 발견되면 catch문 뒤에, 아니면 try문 이어서 실행

throw : 예외 던지기, 예외에 맞는 클래스 인스턴스 생성
범용적인 경우에 사용가능한 예외객체만 있지만 적합하지 않을 때, 예외객체를 직접 만들어서 사용 가능

예외객체 덜 만들었을 때 : 덜만들었다는 예외객체 던져주기
throw new UnsupportedOperationException("내일 만들게. 아직 덜 만듦");
--------------------------------------------------------------------------------------------------
문자열 연산에 사용되는 class -> StringBuilder, StringBuffer
1) 문자열 결합
- 합 연산은 메모리 공간 효율성(새 문자열 인스턴스 매번 생성)이 떨어짐
▶ StringBuilder : 생성자로 설정, 문자열 값을 하나 넣어줄 수도 있음, append라는 메소드로 붙이고 싶은 형으로 자료붙이기
(void가 아닌 자기 자신의 참조를 그대로 반환하므로 원래 값에 값이 추가됨), reverse, setCharAt
-StringBuilder와 concat의 차이 : String에 concat 메소드로 붙이면 새 문자열 인스턴스를 만들어서 그 참조에 값을 붙여서 반환(불변)
▶ StringJoiner("구분자", "시작문자", "끝문자") : 문자열 결합, 모양을 만들어 줄 수 있음


규칙적인 구분자로 구분돼있을 때 잘라서 구분 가능 
-> StringTokenizer(자르고싶은문자열,"구분자"); : 자를 때는 잘라서 가져오라는 의미로 nextToken 호출(하나씩 호출됨), 없는데 가져오라고 하면 error남(있든지 없든지 무조건 가져오므로) -> 그 전에 주머니에 있는지 확인 위해 hasMoreTokens로 while문 만들어 확인해보고 값 가져오도록 명령 주어야함
-> split("구분자") : 값을 쪼개서 배열의 형식으로 잘라서 가져다줌

--------------------------------------------------------------------------------------------------
<오늘 수업> 여기부터야아
--------------------------------------------------------------------------------------------------
● collection (p.544)
: 자바에서 알고리즘(자료 구조)를 구현한 클래스, 모든 자료 구조의 부모 인터페이스로서 객체의 모임을 나타냄
▶ List
: 순서(index)가 있는 자료구조로 중복된 원소를 가질 수 있다.
- 삽입한 순서대로 들어가서 index 가짐
▶ 기타 인터페이스 종류
: Set(집합(중복된 원소를 가지지 않는)을 나타내는 자료 구조, Map(키와 값들이 연관되어 있는 사전과 같은 구조), Queue(극장에서의 대기줄과 같이 들어온 순서대로 나가는 자료 구조), Stack(차곡차곡 쌓여서, 뺄 때는 제일 늦게 들어온 순서대로 나감)

●List인터페이스
: 배열로 구현한 것, 리스트의 크기가 자동조정됨

1) ArrayList
: 배열처럼 여러 개의 자료들을 가질 수 있는 하나의 객체
-배열과 비슷한 구조를 가지지만, 사용하기 편하게 클래스의 형태로 만들어줌
- 배열은 index를 통해 읽고 쓰는 작업에 최적화 -> 기능성이 떨어짐, 고정적인 길이값 -> 동적으로 길이값 변화 힘듦
- java.util.ArrayList;
- 집어넣으라고 하면 하나의 박스가 생기면서 삽입, 삽입된 순서에 따라 index 번호 부여 -> 원하는 값 index로 가져올 수 있음
- 다른 곳에 위치한 객체 인스턴스를 참조하는 것, 값을 추가하면 박스가 생기고 그 박스가 객체 인스턴스를 참조 (!= 배열)
- 길이값을 정해주지 않고, 추가만 해주면 됨
- capacity를 통해 사이즈 지정할 수 있지만, 동적으로 변화하는 아이임
▶ add(추가하고싶은객체) : 객체 추가 메소드
- 객체만 다룰 수 있고, 기본형 타입의 value값을 넣을 수 없음(auto-boxing이 되어 담기는 경우o, 기본형이 담기는 것이 아님)
- ex.   list.add(500); 
	// auto-boxing이 일어나면서 500이라는 값을 가진 Integer객체로 변환되어 객체가 담기므로 가능
	list.add(123.123); //기본형 타입을 넣은 것이 x, 기본형은 넣을 수 없음

▶ size : 객체 안에 담긴 객체의 개수 확인 메소드
▶ get(index번호) : 해당 인덱스번호에 있는 객체 참조 반환 
▶ 전체 원소 한 바퀴 돌려면? : for문 사용, 그냥 for문보다 for-each루프문을 사용하는 것이 좋음
* 추가, 삭제 등은 for문 xxxxxxx, 볼 때만 사용
- for-each문 사용 예시
for(Object o : list) {
	System.out.println(o);
} 
▶ 정수 원소의 모든 합 구하려는 상황 같은 경우 -> generic<> : ArrayList가 하나의 타입을 다룰 수 있도록 지정
- 배열 원소의 타입 지정하고 사용 가능 -> ex. ArrayList<객체타입> list = new ArrayList<객체 타입>(); // 지정해준 타입만 넣어야 함, 왼쪽에 타입 지정했으면 오른쪽엔 <>만 둬도 됨
* 원소에 넣을 때,원래라면 Double은 int형 표현이 가능하지만, int형으로 작성한 것이 Double로 auto-boxing이 안이루어지므로, 원시형으로 double형임을 입력해주어야함

- generic 안쓰면 기본적으로 object 타입으로 담겨진 객체원소들이므로 downcasting 해주어야함 -> 비효율적

● ArrayList의  부모 : List(util패키지, 객체x 인터페이스) - 부모의 인덱스로도 객체 호출 가능
	-> upcasting돼도 ArrayList 사용 가능

* windows - show view에서 outline등 원하는 창 켜서 볼 수 있음

▶ list에 toString 정의되어있어서 문자열의 형태로 출력하고 싶을 때 list.toString()하면 배열 형태로 전체 출력됨
- 이렇게도 가능 System.out.println(list);

▶ set(index번호, 변경 값) : index에 맞는 들어간 값 변경(참조가 변경된 것)
▶ list에 값이 들어있는지 확인 : contains(찾는값) -> true, false로 알려줌
▶ list에 찾는 값의 index 번호 : indexOf(찾는값) -> index 번호 출력
  lastIndexOf(찾는값) -> 뒤에서부터 값 찾아서 index 번호 출력
▶ remove(index번호) : 번호에 맞는 원소값 삭제 -> 사이즈가 줄어들면서, 삭제된 index를 뒤 index가 채워줌(index가 줄어듦)
  remove(값) : contains를 통해 equal한지 확인하고 동등하면 객체값으로 지울 수 있음
-remove는 Object형을 받을 수도 있기 때문에 Object형 값 받아서 지울 수도 있음
	ex. list.remove(Integer.valueOf(23))
▶ add(index번호, 넣고자하는값) : 번호 위치에 값 추가, size 변경, index가 밀려남
▶ clear() : list에 값을 전부 지우기, for문으로 remove써서 지우면 index 번호 바뀌면서 다 안지워지므로 사용x
▶ 리스트가 다 지워졌는지 확인 : list.size() == 0 or list.isEmpty()]

-인터페이스인 iterable(반복 가능한) 특징을 상속받고 있음 -> iterator를 반환가능

▷ iterator : 리스트의 원소를 하나하나 볼 수 있도록 도와주는 객체, <>generic 붙일 수 있음(하나씩 꺼내오기 위한 인스턴스 만들어줘야함), 리스트 원소를 참조해서 가리키고 있음
- next로 다음 객체 불러올 수 있음, 없어도 불러올 수 있으므로 error 발생할 수 있음 -> 그전에 hasNext() 다음원소 있는지 물어보기
- ex. 
while(iterator.hasNext()) {
	System.out.println(iterator.next()); // next로 다음 객체 불러올 수 있음
}
* for-each는 나열, 확인 용도로만 사용하고 다른 작업은 안되는 아이라서 사용x
- 원소 순환 중 삭제를 하기 위해서는 iterator.remove가 필수!!, 참조하고 있으므로 iterator 객체가 있어도 자기 자신껄 지우는게 아닌 참조하고 있던 list의 원소가 삭제됨
- ex. List<Integer> list = new ArrayList(리스트명);
		// 생성자 안에 List를 넣어주면 그에 해당하는 원소를 그대로 가져올 수 있음

▷ Arrays.asList : 리스트 편하게 만들기
-ex.
List<Integer> list = new ArrayList(Arrays.asList(10, 20, 30, 40, 50)); // 생성자로 리스트 만들면 원소 추가, 삭제 가능
List<Integer> test = Array.asList(10, 20, 30, 40, 50); // 원소 추가, 삭제 불가

▶ addAll() : () 안 원소 전부 추가
-ex. List.addAll(Arrays.asList(60, 70, 80)); // 생성자에 추가하지 않고, 이후에 여러 개 추가하고 싶을 때, 생성자에 추가하는 거랑 똑같음
▶ removeAll() :() 안 원소 전부 지움
▶ containsAll() : () 안 원소 다 있는지
▶ subList(index시작, index 끝) : 원하는 index 구간의 값을 가지는 새 리스트를 만들어줌

▷ Collections.sort(리스트 1개); : 리스트 오름차순 정렬(list 작업을 수월하게 도와주는 인터페이스)
▷ Collections.binarySearch(리스트, 값) : 이진검색, 찾고자 하는 값의 index 번호 알려줌, 
-> 같은 숫자 중 하나 지우기 등 할 때는 정렬부터 해줘야함(왼쪽부터 찾을건지, 오른쪽부터 찾을건지)
▷ Collections.reverse(리스트) : 순서 역순 출력
▷ Collections.shuffle(리스트) : 순서 섞어서 출력
▷ Collections.max(list) / min(list) : 최대/최소값
▷ Collections.fill(list, 값) : 길이값은 그대로 유지, 원소값을 원하는 값으로 전부 변경
▷ Collections.replaceAll(list, 기존 값, 변경하고자 하는 값) : 기존 값 중 원하는 기존 값을 변경하고자 하는 값으로 변경
▷ Collections.copy(list, 리스트1) : 리스트1의 값이 리스트에 복사되어 각 인덱스에 자리 잡음(복사될 만큼의 칸이 없으면 안됨)


* random 클래스
- ex
Random random = new Random();
int result = random.nextInt(11); // nextInt(숫자) : 0부터 숫자-1까지의 값 안에서 하나 가져옴 