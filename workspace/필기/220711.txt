<저번 시간 복습>
input : 외부의 자원을 우리 자원으로 가지고 오는 것
-> input stream : 외부의 자원을 가지고 올 때 필요한 매개 
	ex. scanner
	- 입력 방향 변경 불가
	- 재사용 불가, 다 사용했으면 stream을 닫아주어야하는 필수적 책임 가짐

--------------------------------------------------------------------------------------------------
<오늘 수업>

flush() - buffer를 비워내는 것이 언제나 일어나는 것이 아님, buffer가 가득 찼을 때만 출력이 일어나므로 확인 절차로 출력을 완료시키고자 임시공간 비워줌
- buffer를 가지는 경우에만 사용
* 현재까지 배운 stream은 랜덤액세스(원하는곳에서부터 내용 가져오기)가 안되므로 일방향성을 가짐(한 번 읽으면 앞으로 돌아가거나 할 수 x) -> 재사용 불가, 그리고 닫기까지하면  확실히 재사용 불가

● 파싱 : 가져오는 내용을 원래 형으로 맞춰주기
-> outputStream할 때 자료의 형이 list면  inputStream할때도 list여야함 => 데이터는 입출력시 데이터형이 맞아야 함


● 원시형 자료형 그대로 내용 가져오기 (p.632)
=> DataInputStream, DataOutputStream
- byte 단위 출력 -> int는 int형태로 출력하므로 사람이 보는 형태와 다름(컴퓨터 언어로 출력) but 읽을 때는 형변환 없으므로 편리(java 원시형 자료대로 가져오므로 java에서는 편함)
- 파일형을 불러오는 메소드가 너무 다양하므로 파일의 끝을 알려주는 약속이 존재하기 힘듦 => 예외로 알려줌 EOFException 
- 각 자료형의 크기가 다르므로, 쓸 때와 동일한 순서로 읽어야 함(순서중요)
(IOException의 자식), 따로 예외처리 해주면 됨
* FileNotFoundException도 IOException의 자식
* 문자형으로 출력된 자료는 사람이 읽을 수 있으므로 다른 프로그래밍 언어에서도 사용하기 조금 편리

● 객체 정보를 그대로 입출력할 수 있는 stream
=> ObjectOutputStream, ObjectInputStream
- 객체에서 static은 객체가 아니므로 읽고 쓰지 않음, 직렬화할 때 빼고 싶은 부분은 transient(직렬화대상에서 제외) 사용하면 됨
- 읽을 때 기본적으로 Object형으로 읽으므로 형에 맞게 downcasting 필요
- byte stream (사람이 읽을 수 있는 형태로 나오지 x)
- NotSerializableException: 직렬화 불가 => implements Serializable 해주면 됨 (overrride등의 추가적 작업 필요 없음) - 직렬화 가능 -> 입출력으로 정보를 온전하게 사용 가능
▶ 역직렬화(deserialization) : 객체가 직렬화된 데이터를 읽어서 자신의 상태를 복구하는 것

● random access(임의 접근) 파일 - 있더라~정도로만 말해주심
: 파일에 비순차적인 접근을 가능하게 하는 파일 