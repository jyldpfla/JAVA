●LinkedList
: 하나가 지워지거나 추가되면 index가 변경되는 ArrayList와 달리 줄로 연결되어있으므로 추가, 삭제에 용이
 but 원소 전체 순환엔 ArrayList가 유리

●Queue, Deque
-> LinkedList가 implements하고 있음

● 인터페이스를 구현하는 클래스 -> 추상메소드 오버라이드함
------------------------------------------------------------------------------요기부터 오늘!
● Set (556p)
: 중복에만 집중
-인터페이스, 구현체들 존재
▶ 메소드
① add() : 추가
② size() : 크기
③ contains() : 원소 가지고 있는지 여부(index로 확인 x)
④ addAll() : 원소 전체 추가
⑤ retainAll() : 두 Set이 가지고 있는 중복되는 원소만 남기고 지워줌, 교집합만 남도록
⑥ removeAll() : 한 Set의 원소들에서 다른 Set과 중복되는 원소는 전부 지워줌, 차집합(중복되지 않는 부분)만 남도록
⑦ equals() : 1집합과 2집합의 원소가 같은지 확인해서 t/f 값 출력
▶ add를 할 때 원소가 중복된다면, 중복을 걸러내고 추가하지 않음
▶ boolean으로 원소값 추가되었는지 확인 가능
ex. boolean b1 = set.add("qwer");
	// 원소 추가되었는지 true, false로 출력
▶ list와 다르게 원소들의 index를 가지지 않음 -> get이라는 행동 존재x
▶ 원소 전체 순환 - get이 없으므로 for문으로 전체 순환x
	-> for-each문으로 값 하나씩 넘겨받아서 출력해야함
	-> iterator implements하고 있으므로 사용해 출력해야함 (iter.hasNext묻고 .next통해 while문으로 출력)
	- 순서 신경쓰지 않으므로 출력 시 삽입순서에 관계없이 출력됨
- List에서 중복 제거한 상태의 원소들만 얻고 싶을 때 -> Set 사용(알아서 중복을 걸러내주므로 원소 전체 넣어주면 됨)
	-> 생성자 안에 바로 List 객체 넣어주면, set형태로 바로 중복 걸러서 원소 들어감
		-ex. Set<String> set = new HashSet<>(list);
- 두 개의 모든 Set값을 포함하는 Set을 만들고 싶을 때 -> for-each문, iterator, addAll메소드 사용
▶ 집합연산에 최적화 -> 메소드로 제공하고 있음 - retainAll(교집합), removeAll(차집합), equals
* 교집합 boolean값으로 원소 추가됐는지 확인 후 false인 값만 남도록 메소드짜면 만들 수 있음
▶ hash code 
: 각 객체마다 가지고 있는 고유한 숫자값, 객체의 특징(필드)를 숫자로 표현
- set은 hash를 먼저 살펴보고, hash가 다르면 다르다고 판별(판별 첫기준) - hash 명령 없으면 같은 값을 가져도 인스턴스 다르므로 다른 hash값 출력
	-> 동등한 객체끼리는 같은 hash값을 가지도록 해주어야 함
	=> Object에 정의된 메소드로 hash를 재정의(override) 해주어야함 - Objects.hash(필드명);
	(마우스 우클릭, source - hash에서 위 메소드 추가하는거 체크하거나, 그냥 체크 없이 만들어주면 재정의 쉽게 가능)
- Object.hash() : 숫자값을 만들어내는 메소드, 안에 값이 같으면 같은 숫자값을 출력해냄, Object를 가변인자로 가짐,
		  hash 정의가 있어야 정확한 값을 출력할 수 있음
- hash 값이 같은지 본 뒤, 같으면 진짜 같은지 확인 위해 equals까지 호출됨

▷ Set은 hash값으로 값이 동등한지 여부 판별이 쉬우므로, 값의 존재여부/중복여부 판별에 유리, List는 그 외 정렬, 검색등의 경우에 유리

1) HashSet
: 추가된 순서 x
- java.util 패키지
- Set타입으로 변환해서 사용 가능, generic<> 사용 가능
2) LinkedHashSet
: 추가된 순서를 그대로 기억해서 출력시에도 유지됨
- set이므로 index 없음
- util
▷ HashSet과 LinkedHastSet의 합 연산 -> 어느 인스턴스에 넣는지 확인 잘해야함
	LinkedHashSet에 HashSet 넣으면 순서 유지된 채로 들어감, HashSet에 LinkedHashSet에 넣으면 순서 사라짐
3) TreeSet
: 대소비교가 가능한 원소들을 넣으면, 대소크기대로(오름차순 정렬이 된 상태처럼) 출력됨
- String은 영어는 알파벳, 한글은 가나다라 순으로 출력(String에 compareTo 되어있는 상태로)
- 비교기준 없으면 Comparable 이용해서 compareTo메소드 만들어서 비교 기준 지정해주어야 함

● Map (563p)
: 집합에서의 고유한 값과 그 값을 연결하는 친구(키)로 구성(둘이 짝꿍), 많은 데이터중에서 원하는 데이터를 빠르게 찾을 수 있는 자료 구조
- key는 중복x, 각 키는 오직 하나의 값에 매핑될 수 있음 -> 키가 중복되게 값을 추가하면 값이 덮어씌워져서 앞에 값 사라짐
- util
- generic에 <key타입, value타입> 입력해주어야함
- Iterator 사용가능
▶ 메소드
ⓛ put(key, value) : 2개의 객체를 받아서 추가
② size() : 크기
③ get() : 키 객체 1개를 전달 받으면 해당 value 나옴
	- 없는 값 받고 출력하면 null 반환
③ containskey() : key값이 있는지 여부, t/f로 반환
④ keySet() : 키를 반환할 때(key는 set으로 관리됨)
⑤ entrySet() : 키와 값을 한덩어리로 묶은 박스
⑥ remove(키값) : 삭제 

▶ map값 순환 : iterator, for-each문, Entry 이용해도 됨
	-> keySet(키들을 담아둔 곳)을 이용해 키를 반환하고 키로 value 반환
1) HashMap
- hashmap의 기본 toString : public final String toString() { return key + "=" + value; }
2) LinkedHashMap
3) TreeMap

