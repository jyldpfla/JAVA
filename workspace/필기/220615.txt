● abstract 메소드 = 추상 메소드 (p.267)
: 동작에 대한 구체적인 것이 없음 -> 메소드 body에 구체적으로 동작을 쓰는데, 없으므로 {}(body)가 없고 메소드 헤더만 존재
: 완전하게 구현되어 있지 않은 메소드를 가진 클래스
- 추상적인 클래스라서 메소드를 만들 수 없을 때 키워드 붙임
- 사용
: public abstract 리턴타입 메소드명(); -> ;로 꼭 끝내야함
	ex. public abstract int getArea(); 
- 일반적인 클래스에는 존재할 수 없음 -> 인스턴스화(객체화)한 객체는 동작을 가지는데, 동작이 추상적이므로 인스턴스화했을 때 메소드 구현이 없으므로 미완성 객체가 됨
	=> 추상적인 클래스일때만 사용 가능 
▶ abstract(추상) 클래스 : 추상 메소드를 가지고 있는(사용할 수 있는) 클래스
- 사용
: public abstract 클래스명 {
}
- 객체화할 수 없음 -> 미완성인 메소드가 있기 때문에 미완성인 클래스가 되므로 인스턴스화 불가
- 부모 클래스로 같은 부분 가진 자식 클래스를 묶기 위해 만든 클래스라고 생각하면 됨
▶ 추상클래스의 자식클래스
1) 자식클래스 : 일반적 클래스
-> 자식클래스가 일반적인 클래스라면 부모가 가진 추상적인 메소드를 구체화할 책임이 있음 - 메소드 헤드 그대로 가지고 와서 override해야함 => 'implement구현한다' 고 부름
- 자식클래스를 추상클래스로 upcasting 후 부모 클래스 참조해서 실제 instance에 동작을 시켜도 구체화된 자식 클래스에서 메소드 가져와서 동작
-ex.
Shape s = t; // upcasting
System.out.println(s.getArea()); // 도형은 넓이를 구할 수 있다고 정의되어있음
- 메소드 만들 때 마우스 우클릭 - source - override method 누르면 헤드 따와서 바로 입력 가능

2) 자식클래스 : 추상클래스
-> 자식 클래스도 추상적인 클래스라면, abstract 붙이면 됨
- 자식 클래스에서 override해서 메소드 구체화 시켜도 됨
- 손자 클래스에서는 추상클래스인 자식클래스의 추상메소드 구체화해야함, 만약 자식클래스가 부모 클래스 메소드 구체화 안했으면, 손자클래스가 그 메소드까지 구체화할 책임 가짐 
- 자식 클래스에서 구체화된 메소드를 손자 클래스에서 다시 재정의하면 손자 클래스에서 재정의한대로 덮어쓰기 됨

● 종단 클래스 final class
: 더이상 클래스를 상속할 수 없게 만드는 클래스, 상속을 시킬 수 없는 클래스 -> 더이상의 확장을 불가능하게 함(보안 상 이유)
- private로 필드를 보호하려고 해도, 상속을 할 수 있으면 접근제한자의 역할을 다 해내지 못하므로
- 종단 클래스는 상속이 안되므로 전체 메소드는 재정의 될 수 없음
- 사용
: public final class 클래스명 extends 부모클래스 {}
- ex. public final class MyImpleClass extends MySubClass // MyImpleClass 상속 불가
▶ 종단 메소드 final method
: 클래스에서 final method를 지정하면, 상속받은 자식클래스가 override(재정의)할 수 없음
- 특정한 메소드만 override 못하게 하고 싶을 때 설정
- 사용
public final void 메소드명() {} // 자식클래스에서 재정의 불가

* 다형성 : 수퍼 클래스 타입 변수로 서브 클래스 타입의 객체를 참조할 수 있는 중요한 기법
* 수퍼클래스에서 내용이 없는 일반 메소드(메소드명() {})로 정의한 것과 추상 메소드로 정의하는 것의 차이 -> sub클래스에서 무조건 구현 강요하고 안하는 것에 차이가 o

● 인터페이스 Interface (p.270)
: 추상메소드들로만 이루어짐
: java는 다중상속이 안 됨 (하나의 부모클래스만 상속 가능) -> 추상적인 동작을 가지는 인터페이스로 실현 가능, 객체들간의 소통 통로
- 여러 개의 상하구조를 만들어 낼 수 있음
- 클래스처럼 하나의 타입으로 사용 가능, 인스턴스화 시켜서 사용할 목적은 아님 -> new 연산자 사용해서 instance화 불가
- 연관관계 없는 변수는 타입으로 사용 불가
- 이름 : 대문자로 시작, 추상적인 동작을 주로 표현하므로 able(~ 할 수있다)로 이름 짓는 경우 많음 + 클래스명과 혼동하지 않기위해 I를 제일 앞에 붙이고 대문자로 시작하는 이름연결해도 됨
- 추상 메소드만을 가짐, 추상클래스와 달리 일반메소드 가질 수 없음, 필드 가지지 않음(선언불가)
- 추상메소드, 상수만 가질 수 있으므로 abstract 생략 가능, 무조건 public이므로 생략 가능
▶ 사용
: class 명 extends 부모클래스 implements 인터페이스명 {}
상속표현 우측에다가 구현하고자 하는 메소드 이름
- 메소드 다시 재정의하므로 @override 필요
- 인터페이스를 구현하는 구현체들(클래스들)은 무조건 메소드를 재정의 해야함
- 인터페이스는 인터페이스를 상속할 수 있음 (구현이 아니므로 extends로 상속시켜주어야 함) -> 추상적인 동작을 안에 추가적으로 주고 싶을 때
	ex. interface IHello {
			void hello();
		}

interface EngHello extends IHello { // 구현이 아니라 인터페이스 상속이므로 extends
	void howoldru();
}

interface KorHello extends IHello { // 구현이 아니라 인터페이스 상속이므로 extends
	void whoisyourfather();
} 

● 인터페이스 comparable
: 객체의 크기를 비교할 때 사용
▶ 정의
public interface Comparable {
	// 이 객체가 다른 객체보다 크면 1, 같으면 0, 작으면 -1을 반환한다.
	int compareTo(object other);
}
- public int compare(Member member) {
		return height - member.height; // 크면 양수, 같으면 -, 작으면 음수
	} // 나오는 숫자로 대소비교 가능 -> 메소드로 정의된 것이라고 생각하면 됨
- 사용 : implements Comparable로 구현
*generic <>
구현할 인터페이스 옆에 좌우 중 한 곳에<> 넣고 안에 비교할 대상 넣으면 안전하게 비교 가능
-compareTo()안에 Member형 파라미터 선언
-ex. 
class Member implements Comparable<Member> {
	private String name; // 이름
	private int height; // 키
	private int weight;	// 몸무게

	@Override
	public int compareTo(Member o) {
		// 원래 head는 파라미터가 Object로 되어있어서 <>선언해주어야 Member형으로 사용 가능
		return this.height - o.height;
	}
- double은 근사값이 있어서 오차가 생길 수 있으므로 비교할 때 조심해서 해야함
- 두 객체가 모두 Comparable 인터페이스를 구현한다면 서로 비교 가능
- 배열에 들어있는 데이터를 정렬하는 방법 : Arrays 클래스 안에 정의된 sort() 정적 메소드를 사용하려면 대상 객체가 comparable 인터페이스를 구현하고 있는 경우에만 사용 가능
