생성자(constructor)
: 클래스 이름이랑 똑같이 생김, return type이 존재x, 파라미터 있고 {}로 범위 지정
▷ {} 안 : 생성자의 목적인 필드 초기화 내용이 포함
▷ () : 생성자 파라미터, 안에 요소 넣으면 됨, 파라미터라 각각 이름 필요
1) 기본 생성자
: 필드를 기본값으로 초기화
- 정수형은 0, 실수형은 0.0, 논리형은 false, 참조형 null
- 기본 생성자가 없을때만 컴파일러가 기본 생성자를 만들어주고 호출 → 디폴트 생성자
- 만든 생성자의 파라미터에 맞춰서 값 안주면 error뜸, 파라미터 잘 설정해야함
- 생성자는 여러 개 만들 수 있음 -> 기본 생성자를 두고 싶으면 기본 생성자를 명시적으로 만들어두면 됨
- 중복 정의
- 타입, 순서, 개수로 메소드와 생성자의 일치여부를 봄
- 생산자 안에서 문장의 순서 중요 -> 자기 자신을 부르는 this는 언제나 생산자 첫 줄이어야함

* 호출하면 흐름이 흘러감, 
* this는 자기 자신을 가리킴

접근 제한자 - public, private, 빈 자리
● private
:외부에서의 필드에서나 메소드에서는 해당 필드를 접근해서 볼 수도 변경할 수도 없음, 자기 자신의 범위 안에서만 사용 가능
- 정보 보호 가능, 바깥에서 볼 필요 없는 정보를 숨길 수 있음
-> 정보를 숨겨두고 원할 때 메소드를 통해 호출 가능
	메소드를 이용하면 추가적인 논리적 흐름 추가 가능(ex. if문 추가해서 boolean값으로 도출해내기 등등)
-> 초기화는 main에서 하는데, 객체지향적 사고를 하면 하나의 공통적인 행동에 대해서 하나의 객체가 스스로 행동을 하도록 하므로, 객체에서의 메소드 호출을 통해 여러곳에서 같은 동작을 논리적으로 수행하도록 해야함
이 때 private 접근제한자를 사용하면, 요청 값을 직접적으로 입력하지 않고, 값을 전달하고 호출하는 메소드를 통해 값을 설정하도록 함, 즉 값을 줄 수 있는 경로가 정해져있으므로 그 경로만 관리해주면 관리 가능

▷ 캡슐화: 외부에서 정보를 함부로 사용할 수 없도록 내부에서 보호
▷ 추상화: 사용자가 불필요한 정보를 보지 않도록 숨겨줌

▶ setter 설정자 : 값을 받아와서 설정
▶ getter 접근자 : 값을 알려주는 경우

● public
:외부에서의 필드, 메소드에서도 해당 필드를 접근해서 볼 수도 변경할 수도 있음, 자기 자신의 범위 외에서도 사용 가능
- private를 통해서 main에서 값을 입력하고, 자기 자신을 제외한 외부에서 값을 확인할 수 없도록 설정 가능

* 객체는 자기 자신을 문자열로 표현할 수 있음

